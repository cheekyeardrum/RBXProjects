-- Clean Hub (GUI Framework + Grass Upgrade Tab)

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer
local guiParent = CoreGui

-- Sizes
local HUB_SZ = UDim2.new(0,700,0,450)
local MINIMIZED_SZ = UDim2.new(0,200,0,40)

-- Tween helper
local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local function tween(obj, props)
    local tw = TweenService:Create(obj, tweenInfo, props)
    tw:Play()
    return tw
end

local function round(ui, radius)
    local c = Instance.new("UICorner", ui)
    c.CornerRadius = UDim.new(0, radius or 8)
end

-- ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CleanHubGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = guiParent

-- Main Frame
local frame = Instance.new("Frame", screenGui)
frame.Name = "MainFrame"
frame.Size = HUB_SZ
frame.Position = UDim2.new(0.5,0,0.5,0)
frame.AnchorPoint = Vector2.new(0.5,0.5)
frame.BackgroundColor3 = Color3.fromRGB(20,20,20)
frame.Active = true
frame.BorderSizePixel = 0
round(frame,10)

-- Dragging
local dragging, dragInput, dragStart, startPos
UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset+delta.X,
            startPos.Y.Scale, startPos.Y.Offset+delta.Y
        )
    end
end)

local function enableDrag(target)
    target.InputBegan:Connect(function(i)
        if i.UserInputType==Enum.UserInputType.MouseButton1 or i.UserInputType==Enum.UserInputType.Touch then
            dragging = true
            dragStart = i.Position
            startPos = frame.Position
            i.Changed:Connect(function()
                if i.UserInputState==Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    target.InputChanged:Connect(function(i)
        if i.UserInputType==Enum.UserInputType.MouseMovement or i.UserInputType==Enum.UserInputType.Touch then
            dragInput = i
        end
    end)
end

-- Top Bar
local bar=Instance.new("Frame",frame)
bar.Size=UDim2.new(1,0,0,40)
bar.Position=UDim2.new(0,0,0,0)
bar.BackgroundColor3=Color3.fromRGB(40,40,40)
bar.Active=true
round(bar,10)
enableDrag(bar)

local title=Instance.new("TextLabel",bar)
title.Size=UDim2.new(1,-120,1,0)
title.Position = UDim2.new(0,10,0,0)
title.BackgroundTransparency=1
title.Font=Enum.Font.SourceSansBold
title.TextSize=24
title.Text="Clean Hub"
title.TextColor3=Color3.new(1,1,1)
title.TextXAlignment=Enum.TextXAlignment.Left

local closeBtn=Instance.new("TextButton",bar)
closeBtn.Size=UDim2.new(0,30,0,30)
closeBtn.Position=UDim2.new(1,-40,0,5)
closeBtn.Text="X"
closeBtn.Font=Enum.Font.SourceSansBold
closeBtn.TextSize=18
closeBtn.BackgroundColor3=Color3.fromRGB(200,50,50)
closeBtn.TextColor3=Color3.new(1,1,1)
round(closeBtn,4)

local minBtn=Instance.new("TextButton",bar)
minBtn.Size=UDim2.new(0,30,0,30)
minBtn.Position=UDim2.new(1,-80,0,5)
minBtn.Text="-"
minBtn.Font=Enum.Font.SourceSansBold
minBtn.TextSize=22
minBtn.BackgroundColor3=Color3.fromRGB(100,100,100)
minBtn.TextColor3=Color3.new(1,1,1)
round(minBtn,4)

-- Tabs + Content
local tabsFrame=Instance.new("Frame",frame)
tabsFrame.Size=UDim2.new(0,140,1,-60)
tabsFrame.Position=UDim2.new(0,0,0,50)
tabsFrame.BackgroundTransparency=1

local contentFrame=Instance.new("Frame",frame)
contentFrame.Size=UDim2.new(1,-140,1,-60)
contentFrame.Position=UDim2.new(0,140,0,50)
contentFrame.BackgroundTransparency=1
enableDrag(contentFrame)

-- Tab Names
local tabNames={"Tab1","Tab2","Tab3","Grass Upgrade","Tree Upgrade"}
local tabButtons={}

-- Empty Tabs
local function buildTab1()
    for _,v in pairs(contentFrame:GetChildren()) do v:Destroy() end
    local label = Instance.new("TextLabel", contentFrame)
    label.Size = UDim2.new(1,-20,1,-20)
    label.Position = UDim2.new(0,10,0,10)
    label.BackgroundTransparency = 1
    label.Text = "This is Tab 1 (empty)"
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.SourceSansBold
    label.TextSize = 20
end

local function buildTab2()
    for _,v in pairs(contentFrame:GetChildren()) do v:Destroy() end
    local label = Instance.new("TextLabel", contentFrame)
    label.Size = UDim2.new(1,-20,1,-20)
    label.Position = UDim2.new(0,10,0,10)
    label.BackgroundTransparency = 1
    label.Text = "This is Tab 2 (empty)"
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.SourceSansBold
    label.TextSize = 20
end

local function buildTab3()
    for _,v in pairs(contentFrame:GetChildren()) do v:Destroy() end
    local label = Instance.new("TextLabel", contentFrame)
    label.Size = UDim2.new(1,-20,1,-20)
    label.Position = UDim2.new(0,10,0,10)
    label.BackgroundTransparency = 1
    label.Text = "This is Tab 3 (empty)"
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.SourceSansBold
    label.TextSize = 20
end

-- Grass Upgrade Tab
local upgrading = false
local connection

local function fireGrassUpgrades()
    -- Upgrade 1
    local args1 = {
        buffer.fromstring("\002\n\000SpawnRate1\000\001\0001\001\0007\005\000Grass\001\0005")
    }
    game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args1))

    -- Upgrade 2
    local args2 = {
        buffer.fromstring("\002\n\000GrassValue\000\001\0001\002\00099\005\000Grass\001\0002")
    }
    game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args2))

    -- Upgrade 3
    local args3 = {
        buffer.fromstring("\002\v\000GrassAmount\000\001\0001\002\00049\005\000Grass\001\0003")
    }
    game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args3))
end

local function buildGrassUpgradeTab()
    for _,v in pairs(contentFrame:GetChildren()) do v:Destroy() end

    local label = Instance.new("TextLabel", contentFrame)
    label.Size = UDim2.new(1,-20,0,40)
    label.Position = UDim2.new(0,10,0,10)
    label.BackgroundTransparency = 1
    label.Text = "Grass Upgrades"
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.SourceSansBold
    label.TextSize = 22

    local toggle = Instance.new("TextButton", contentFrame)
    toggle.Size = UDim2.new(0,200,0,50)
    toggle.Position = UDim2.new(0,20,0,60)
    toggle.Text = "OFF"
    toggle.Font = Enum.Font.SourceSansBold
    toggle.TextSize = 20
    toggle.BackgroundColor3 = Color3.fromRGB(150,50,50)
    toggle.TextColor3 = Color3.new(1,1,1)
    round(toggle,8)

    toggle.MouseButton1Click:Connect(function()
        upgrading = not upgrading
        toggle.Text = upgrading and "ON" or "OFF"
        toggle.BackgroundColor3 = upgrading and Color3.fromRGB(50,150,50) or Color3.fromRGB(150,50,50)

        if upgrading then
            connection = RunService.RenderStepped:Connect(fireGrassUpgrades)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end)
end


-- Improved Tree Upgrade tab (debug + fallbacks)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local upgradingTrees = false
local treeLoop

local treeUpgradePaths = {
    workspace.World.Scriptable.TreeUpgrades1.UpgradeConfig,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade1,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade10,
    workspace.World.Scriptable.TreeScriptable and workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade12 or workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade12,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade12,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade13,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade14,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade15,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade17,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade2,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade3,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade4,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade5,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade6,
    workspace.World.Scriptable.TreeUpgrades1.TreeUpgrade8,
}

local function findMainPart(upgrade)
    if not upgrade or typeof(upgrade) ~= "Instance" then return nil end
    -- Prefer Pad.Main
    local pad = upgrade:FindFirstChild("Pad")
    if pad then
        local main = pad:FindFirstChild("Main")
        if main and main:IsA("BasePart") then return main end
    end
    -- Fallback: any BasePart that has a TouchInterest child
    for _,desc in ipairs(upgrade:GetDescendants()) do
        if desc:IsA("BasePart") and desc:FindFirstChild("TouchInterest") then
            return desc
        end
    end
    -- Last resort: first BasePart descendant
    for _,desc in ipairs(upgrade:GetDescendants()) do
        if desc:IsA("BasePart") then return desc end
    end
    return nil
end

local function simulateTouch(part, hrp)
    if not part or not hrp then return false, "missing args" end

    -- 1) Try exploit-provided firetouchinterest
    if type(firetouchinterest) == "function" then
        local ok,err = pcall(function()
            firetouchinterest(hrp, part, 0)
            firetouchinterest(hrp, part, 1)
        end)
        if ok then return true, "firetouchinterest" end
    end

    -- 2) Try calling server callbacks attached to Touched via getconnections (exploit-specific)
    if type(getconnections) == "function" then
        local ok,conns = pcall(function() return getconnections(part.Touched) end)
        if ok and conns and #conns > 0 then
            for _,c in ipairs(conns) do
                pcall(c.Function, part, hrp)
            end
            return true, "getconnections"
        end
    end

    -- 3) Try find a TouchInterest instance (some exploit APIs expose ways to trigger it)
    local ti = part:FindFirstChild("TouchInterest")
    if ti then
        -- Some exploits provide ti:Fire or similar; try pcall as fallback
        if type(ti.Fire) == "function" then
            pcall(function() ti:Fire(hrp) end)
            return true, "TouchInterest:Fire"
        end
    end

    return false, "no-method-available"
end

local function fireTreeUpgrades()
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
    if not hrp then
        warn("[TreeUpgrade] No HRP found for player")
        return
    end

    for _, upgrade in ipairs(treeUpgradePaths) do
        local ok, part = pcall(findMainPart, upgrade)
        if not ok or not part then
            warn("[TreeUpgrade] couldn't find part for", tostring(upgrade))
        else
            local success, method = simulateTouch(part, hrp)
            if success then
                print("[TreeUpgrade] touched", part:GetFullName(), "via", method)
            else
                warn("[TreeUpgrade] failed to touch", part:GetFullName(), "(", method, ")")
            end
        end
    end
end

-- Example toggle builder (adapt into your UI code)
local function startTreeLoop()
    if treeLoop then return end
    treeLoop = task.spawn(function()
        while upgradingTrees do
            fireTreeUpgrades()
            task.wait(0.2)
        end
        treeLoop = nil
    end)
end

local function stopTreeLoop()
    upgradingTrees = false
    -- loop will exit itself
end

-- quick debug helper (run in executor console first to check availability)
print("DEBUG: firetouchinterest exists? ", type(firetouchinterest))
print("DEBUG: getconnections exists? ", type(getconnections))


-- Tab Functions
local tabFuncs = {buildTab1,buildTab2,buildTab3,buildGrassUpgradeTab,buildTreeUpgradeTab}
for i,name in ipairs(tabNames) do
    local btn = Instance.new("TextButton", tabsFrame)
    btn.Size = UDim2.new(1,0,0,40)
    btn.Position = UDim2.new(0,0,0,(i-1)*45)
    btn.Text = name
    btn.Font = Enum.Font.SourceSansBold
    btn.TextSize = 16
    btn.BackgroundColor3 = Color3.fromRGB(50,50,50)
    btn.TextColor3 = Color3.new(1,1,1)
    round(btn,6)
    local func = tabFuncs[i]
    btn.MouseButton1Click:Connect(func)
    table.insert(tabButtons, btn)
end

-- Close/Minimize
closeBtn.MouseButton1Click:Connect(function() screenGui:Destroy() end)
minBtn.MouseButton1Click:Connect(function()
    if frame.Size==HUB_SZ then
        tween(frame,{Size=MINIMIZED_SZ})
    else
        tween(frame,{Size=HUB_SZ})
    end
end)

-- Default tab
buildTab1()
